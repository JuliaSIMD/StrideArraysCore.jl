var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = StrideArraysCore","category":"page"},{"location":"#StrideArraysCore","page":"Home","title":"StrideArraysCore","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [StrideArraysCore]","category":"page"},{"location":"#StrideArraysCore.rank_to_sortperm-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N","page":"Home","title":"StrideArraysCore.rank_to_sortperm","text":"rank_to_sortperm(::NTuple{N,Int}) -> NTuple{N,Int}\n\nReturns the sortperm of the stride ranks.\n\n\n\n\n\n","category":"method"},{"location":"#StrideArraysCore.@gc_preserve-Tuple{Any}","page":"Home","title":"StrideArraysCore.@gc_preserve","text":"@gc_preserve foo(A, B, C)\n\nApply to a single, non-nested, function call. It will GC.@preserve all the arguments, and substitute suitable arrays with PtrArrays. This has the benefit of potentially allowing statically sized mutable arrays to be both stack allocated, and passed through a non-inlined function boundary.\n\n\n\n\n\n","category":"macro"}]
}
